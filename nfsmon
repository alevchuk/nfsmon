#!/usr/bin/env ruby


require 'curses'


trap("INT"){ exit } 

if ! [1,2].include?(ARGV.size)
  STDERR.puts "ERROR: Invalid number of arguments #{ARGV.size}"
  STDERR.puts "Usage: #{File.basename(__FILE__)} <probe-directory>" +
    " [<page>]"
  STDERR.puts ""
  STDERR.puts "  <probe-directory>  is where pstmd is running"
  exit 1
end
PROBE_DIR = File.directory?(ARGV[0]) ? ARGV[0] : File.dirname(ARGV[0])
LOGFILE_PREFIX = "/srv/projects/zeus_log/nfs-fileio"

PAGE = ARGV[1].nil? ? 1 : ARGV[1].to_i

def restart_curses
  Curses.noecho # do not show typed keys
  Curses.init_screen
  Curses.stdscr.keypad(true) # enable arrow keys (for pageup/down)
  Curses.stdscr.nodelay = 1
  Curses.clear
  Curses.setpos(0,0)
  Curses.refresh
end
restart_curses

def get_terminal_dimentions
  @COLS = `tput cols`.to_i
  @ROWS = (`tput lines`.to_i - 1)
end

get_terminal_dimentions
#Thread.new {loop {get_terminal_dimentions; sleep 0.3}}

class Integer
  def rj; self.to_s.rjust(2, '0') end
end

def custom_to_log_format(x) # To sring
  "#{x[:y]}-#{x[:month].rj}-#{x[:d].rj}_#{x[:h].rj}-#{x[:m].rj}"
end

def custom_to_s(x) # To sring
  "#{x[:y]}-#{x[:month].rj}-#{x[:d].rj} #{x[:h].rj}:#{x[:m].rj}"
end

def debug(j) # j is a custom structure - a hash of hashes
  STDERR.puts j.collect {|x, count| "#{custom_to_s(x)} #{count}"}.sort.reverse
  STDERR.puts
end



def get_actual
  actual = Hash.new(0)
  `cat #{PROBE_DIR}/log | cut -f1 | uniq -c`.each_line do |line|
    count, timestamp = line.split(' ')
    date, time = timestamp.split('_')
  
    y,month,d = date.split('-')
    h,m = time.split('-')

    y=y.to_i; month=month.to_i; d=d.to_i; h=h.to_i; m=m.to_i; count=count.to_i

    actual[{:y=>y, :month=>month, :d=>d, :h=>h, :m=>m}] = count
  end
  
  actual
end

def get_expected(page)
  t_now = Time.now
  range = (t_now - @ROWS * 60 * page)..(t_now - @ROWS * 60 * (page - 1))

  range.step(60).to_a.reverse.collect do |t|
    {:y=>t.year, :month=>t.month, :d=>t.day, :h=>t.hour, :m=>t.min}
  end
end


#debug get_actual
#debug get_expected(1)



Curses.clear
Curses.setpos(0,0)

page = PAGE
selected_line = 0
loop_count = 0
@actual = nil
@expected = nil
@current_lines = nil

def read_log(page)
  @actual = get_actual
  @expected = get_expected(page)
end

read_log(page)


get_terminal_dimentions

loop do
  c = Curses.getch

  if c == 113 # q
    restart_curses
    exit
  end

  if c == Curses::Key::PPAGE
    if page == 1
      Curses.clear
      next
    end
    page -= 1
    read_log(page)
  end

  (page += 1; selected_line = 0; read_log(page)) if c == Curses::Key::NPAGE
  (page = 1; selected_line = 0; read_log(page)) if c == Curses::Key::HOME

  (selected_line -= 1) if c == Curses::Key::UP and selected_line != 0
  (selected_line += 1) if c == Curses::Key::DOWN and selected_line != @ROWS


  if c == 10 or c == 32 # Enter or space
    t_list = @expected.sort{|i1,i2| custom_to_s(i1) <=> custom_to_s(i2)}
    t = t_list[@ROWS - selected_line]
    
    file = "#{LOGFILE_PREFIX}-#{custom_to_log_format(t)}"
    Curses.close_screen
    system "less -NS #{file}"
    restart_curses
    Curses.clear
    Curses.refresh
  end


  # Computationally intensive operation
  if loop_count % 20 == 0 and page == 1
    read_log(page)
  end


  Curses.setpos(0,0)
  @expected.each_with_index do |x, index|
    num_stars = @actual[x]
    unfinished = ((index == 0 and num_stars < 58) ? '...' : '')
    line = "#{x[:h].rj}:#{x[:m].rj} " + "*" * num_stars + unfinished +
      " #{@actual[x].to_s.rjust(2,'0')}"

    line_final = line.ljust(@COLS - 3) 
    if index == selected_line
      Curses.standout
      Curses.addstr "|" + line_final + "|\n"
      Curses.standend
    else
      Curses.addstr " " + line_final + "\n"
    end
  end

  get_terminal_dimentions

  sleep 0.05
  loop_count += 1
end
