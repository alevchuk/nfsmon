#!/usr/bin/env ruby


require 'curses'

Curses.noecho # do not show typed keys
Curses.init_screen
Curses.stdscr.keypad(true) # enable arrow keys (required for pageup/down)
Curses.stdscr.nodelay = 1


trap("INT"){ exit } 

if ARGV.size != 1
  STDERR.puts "ERROR: Invalid number of arguments #{ARGV.size}"
  STDERR.puts "Usage: #{File.basename(__FILE__)} <probe-directory>"
  STDERR.puts ""
  STDERR.puts "  <probe-directory>  is where pstmd is running"
  exit 1
end
PROBE_DIR = File.directory?(ARGV[0]) ? ARGV[0] : File.dirname(ARGV[0])

def get_terminal_dimentions
  @COLS = `tput cols`.to_i
  @ROWS = (`tput lines`.to_i - 1)
end

get_terminal_dimentions
#Thread.new {loop {get_terminal_dimentions; sleep 0.3}}

class Integer
  def rj; self.to_s.rjust(2, '0') end
end

def custom_to_s(x) # To sring
  "#{x[:y]}-#{x[:month].rj}-#{x[:d].rj} #{x[:h].rj}:#{x[:m].rj}"
end

def debug(j) # j is a custom structure - a hash of hashes
  STDERR.puts j.collect {|x, count| "#{custom_to_s(x)} #{count}"}.sort.reverse
  STDERR.puts
end



def get_actual
  actual = Hash.new(0)
  `cat #{PROBE_DIR}/log | cut -f1 | uniq -c`.each_line do |line|
    count, timestamp = line.split(' ')
    date, time = timestamp.split('_')
  
    y,month,d = date.split('-')
    h,m = time.split('-')

    y=y.to_i; month=month.to_i; d=d.to_i; h=h.to_i; m=m.to_i; count=count.to_i

    actual[{:y=>y, :month=>month, :d=>d, :h=>h, :m=>m}] = count
  end
  
  actual
end

def get_expected(page)
  t_now = Time.now
  range = (t_now - @ROWS * 60 * page)..(t_now - @ROWS * 60 * (page - 1))

  range.step(60).to_a.reverse.collect do |t|
    {:y=>t.year, :month=>t.month, :d=>t.day, :h=>t.hour, :m=>t.min}
  end
end


#debug get_actual
#debug get_expected(1)



Curses.clear
Curses.setpos(0,0)

page = 1

loop do

  get_terminal_dimentions

  c = Curses.getch

  if c == Curses::Key::PPAGE
    if page == 1
      Curses.clear
      sleep 0.1
      next
    end
    page -= 1
  end

  if c == Curses::Key::NPAGE
    page += 1
  end

  #when Curses::Key::UP
  #  Curses.setpos(0,0)
  #  Curses.clear
  #  Curses.addstr "UP"
  #  Curses.refresh

  if c == Curses::Key::DOWN
    Curses.setpos(0,0)
    Curses.clear
    Curses.addstr "DOWN"
    Curses.refresh

  elsif c == 10 or c == 32 # Enter or space
    Curses.setpos(0,0)
    Curses.clear
    Curses.addstr "ENTER"
    Curses.refresh

  else


  actual = get_actual
  expected = get_expected(page).sort{|x,y| custom_to_s(y) <=> custom_to_s(x)}

  Curses.clear
  Curses.setpos(0,0)

  expected.each_with_index do |x, index|
    num_stars = actual[x]
    unfinished = ((index == 0 and num_stars < 59) ? '...' : '')
    line = "#{x[:h].rj}:#{x[:m].rj} " + "*" * num_stars + unfinished +
      " #{actual[x].to_s.rjust(2,'0')}"
    #Curses.addstr(c.inspect + " ")
    Curses.addstr(line + "\n")
  end
  Curses.refresh


  end

  sleep 0.03
end
